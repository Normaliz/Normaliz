//// Singular library normaliz.lib
version="version sagbiNormaliz.lib 4.4.0.6 Okt_2024 "; // $Id$
category="Commutative Algebra";
info="
LIBRARY: sagbiNormaliz.lib  Provides an interface for the computation of Sagbi bases.
It uses normaliz.lib (version 4... or higher) for combinatorial computations.

AUTHORS: Winfried Bruns, wbruns@uos.de

OVERVIEW:

The library sagbiNormaliz.lib provides functions for the computations of Sagbi bases of
subalgebras A of polynomial rings over a field. It is based on normaliz.lib. Its
functions compute Sagbi bases with or without the control by Hilbert functions and/or
degrees. Hilbert functions and degrees require that bthe ambient polynomial ring is
standard graded. (An extension to general positive gradings would not be difficult.)

In addition to the Sagbi bases it can compute a defining ideal for the algebra A with
respect to the given system of generators. (The computation of defining ideals cannot be
controlled by Hilbert series.)

See the papers

(1) W.Bruns and A. Conca, Sagbi combinatorics of maximal minors and a Sagbi algorithm.
J. Symb. Comput. 120  (2024), Article ID 102237, 14 p. (arXiv:2302.14345)

(2) W. Bruns, A. Conca and F.Lembo, Sagbi bases, defining ideals and algebras of minors.

Use of this library requires the program Normaliz to be installed and the
availability of normaliz.lib. You can download both from
@uref{https://github.com/Normaliz/Normaliz/releases}.
Please make sure that the executable is in the search path or use setNmzExecPath (defined
in normaliz.lib).

The computations of this library require reading Normaliz output files and therefore a file name
must be set. The standard file name chosen by the library is NmzSagbiExchange in the current
directory. The user can change the name.

KEYWORDS: Sagbi basis, initial algebra, defining ideal.

PROCEDURES:
sagbiGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]) computes the Sagbi basis of the subalgebra of
                              the current polynomial ring that is generated by the elements of Q. The computation is stopped after at most sagbiMaxRounds rounds if trhe parameter is set. If sorting is set, the  computed elements are degrevlex sorted before a round of the algorithm.
                              The optional parameter verb sets the terminal output. Default is 1 = on..

sagbiByDegree(ideal Q, int Sagbi_degree_bound,[,int sorting, int verb]) computes the Sagbi basis degree by degree
                               until thwe degree bound is reached or the Sagbi basis has been computed compltely.

sagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound[, int finalCheck, int sorting, int verb])
                              computes the Sagbi basis up to the degree bound. The Hilbert series of the subalgebra
                              generated by the elements of Q is given by its numerator and denominator as a rational
                              function. HS_denom_algebra lists the exponents g_i in the factors 1 -t^g_i of the denominator.
                              If the degree bound is reached and the optional argument inalCheck is set, the Hilbert series
                              is checked again for completion.

sagbiDefIdealGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]) does the same as sagbiGeneral, but additionally
                             computes as much of a system of generators of the defining idael as it can get before being stopped. Addutionally it returns the list of expressions of the Sagbi elements in terms of the original generators of the aubalgebra, calles the retract.

sagbiDefIdealByDegree(ideal Q, int Sagbi_degree_bound,[,int sorting, int verb]) does the same as sagbiByDegree,
                               but additionally computes the defining ideal up to the degree set by Sagbi_degree_bound.
                               Addutionally it returns the list of expressions of the Sagbi elements in terms of the original generators of the aubalgebra, calles the retract.


";
LIB "general.lib";


// ------------------------------------------------
// Helpers for ideal management
//  -----------------------------------------------

static proc leadcoafIdeal(ideal Q){
    ideal LC;
    for(int i = 1; i <= ncols(Q); i++){
        if(i == 1){
            LC[1] = leadcoef(Q[1]);
        }
        else{
            LC = LC, leadcoef(Q[i]);
        }
    }
    return(LC);
}

static proc degIdeal(ideal Q){
    int p = ncols(Q);
    intvec D = 1..p; // to give it size p
    for(int i = 1; i <= p; i++){
        D[i] = deg(Q[i]); // no GradingDenom: only interested in <0, 0 , >0
    }
    return(D);
}

static proc checkPposDegree(ideal Q){
    for(int i = 1; i <= ncols(Q); i++){
        if(deg(Q[i]) <= 0){
            ERROR("Polynomials in input must have positive degree");
        }
    }
}


static proc aapplyLaedIdeal(ideal LC){

    for(int i = 1; i <= ncols(LC); i++){
            if(LC[i] == 0){
                @DefIdeal = @DefIdeal, @Retract[i];
                @Retract[i] = 0;
            }
            else{
                @Retract[i] = @Retract[i]/LC[i];
            }
    }
    @DefIdeal = simplify(@DefIdeal, 3);
    @Retract = simplify(@Retract, 2);
}


 static proc checkDefIdeal(ideal Q){
     map h = @S, Q;
     ideal test_def_Id = h(@DefIdeal);
     test_def_Id = simplify(test_def_Id,2);
     if(size(test_def_Id) != 0){
        ERROR("Defining ideal doesn't map to 0. Inform the authors!");
    }
 }

 static proc removeConstants(ideal Q){
     for(int i = 1; i<=ncols(Q); i++){
         if(deg(Q[i]) == 0){
            Q[i] = 0;
         }
     }
     Q = simplify(Q, 2);
     return(Q);
 }

 static proc preparePreIm(intvec D, ideal LC){

     for(int i = 1; i <= size(D); i++){
         if(D[i] <= 0){ // constant
            @DefIdeal = @DefIdeal, @Retract[i] - LC[i];
            @Retract[i] = 0;
         }
         else{
            @Retract[i] = @Retract[i]/LC[i];
         }
     }
     @Retract = simplify(@Retract, 2);
 }

// ------------------------------------------------
// Helpers related to grading
//  -----------------------------------------------


static proc gradingDenominator(ideal P){
    int GradingDenom = deg(P[1]);
    for(int i = 2; i <= size(P); i++){
        GradingDenom = gcd(GradingDenom, deg(P[i]));
    }
    return(GradingDenom);
}

static proc gradVector(ideal Q, int GradingDenom){
    intvec SGrad;
    SGrad = deg(Q[1]) div GradingDenom;
    for(int i = 2; i <= size(Q); i++){
        SGrad = SGrad, deg(Q[i]) div GradingDenom;
    }
    return(SGrad);
}

static proc scalarProduct(intvec u, intvec v){
    int p = 0;
    for(int i = 1; i <= size(u); i++){
        p = p + u[i]*v[i];
    }
    return(p);
}

static proc posScalarProductMat(intmat U, int row, intvec v){
    int p = 0;
    for(int i = 1; i <= ncols(U); i++){
        if(U[row,i] > 0){
            p = p + U[row,i]*v[i];
        }
    }
    return(p);
}

static proc selectNextDegree(intmat saveTete_a_tete, int startTete_tete, intvec SGrad){

    for(int k = 1; k <= nrows(saveTete_a_tete); k++){
        // posScalarProductMat(saveTete_a_tete, k, SGrad);
    }

    int endTete_atete = nrows(saveTete_a_tete);
    if(startTete_tete > nrows(saveTete_a_tete))
    {
        intmat empty[0][ncols(saveTete_a_tete)];
        return (empty, startTete_tete);
    }

    int startDeg = posScalarProductMat(saveTete_a_tete, startTete_tete, SGrad);
    int i,j;

    for(i = startTete_tete; i <= nrows(saveTete_a_tete); i++){
        if(posScalarProductMat(saveTete_a_tete, i, SGrad) > startDeg)
{
            endTete_atete = i -1;
            break;
        }
    }
    intmat selection[endTete_atete - startTete_tete +1][ncols(saveTete_a_tete)];
    for(i = startTete_tete; i <= endTete_atete; i++){
            for(j = 1; j <= ncols(saveTete_a_tete); j++){
                selection[i - startTete_tete +1, j] = saveTete_a_tete[i, j];
            }
    }
    return(selection, endTete_atete + 1);
}

static proc selectionByDegree(ideal P, intvec grading, int our_deg){
    ideal Q;
    for(int i = 1; i <= size(P); i++){
        if(scalarProduct(leadexp(P[i]), grading) == our_deg){
            Q = Q + P[i];
        }
    }
    return(Q);
}

// ------------------------------------------------
// Helpers for Hilbert series
//  -----------------------------------------------


static proc polyProd(intvec F, bigintmat G, int max_degree){
// F and G represent polynomials in one variable
// We compute their product up to maxdegree
    int deg_F = size(F) - 1;
    int deg_G = ncols(G) - 1;
    int deg_prod = deg_F + deg_G;
    int eff_deg = max_degree;
    if(eff_deg > deg_prod || eff_deg == -1){
        eff_deg = deg_prod;
    }
    bigintmat Prod[1][eff_deg +1];
    int d, j;
    bigint S;
    for(d = 0; d <= eff_deg; d++){
        S = 0;
        for(j = 0; j <= d; j++){
            if(j  <= deg_F && d - j <= deg_G){
                    S = S + F[j + 1]*G[1, d - j +1];
            }
        }
        Prod[1,d + 1] = S;
    }
    return(Prod);
}

static proc cycloRatFunctionExpansion(EnumData HS, int exp_degree){
// Computes the expansion of a rational function with numerator represented by HS.HilbertSeriesNum
// and denominator a product of terms 1 - t^g_i where zjhe g_i are the entries of den_vec

    bigintmat E[1][exp_degree + 1];
    int to_copy = ncols(HS.HilbertSeriesNum);
    if(to_copy > exp_degree + 1){
        to_copy = exp_degree + 1;
    }
    int i, j, k;
    for(i = 1; i <= to_copy; i++){
        E[1, i] = HS.HilbertSeriesNum[1,i];
    }
    intvec fac;
    for(i = 1; i <= exp_degree; i++){
        fac = fac, 0;
    }
    intvec den_vec = HS.HilbertSeriesDenom;
    for( k = 1; k<= size(den_vec); k++){
        for(i = 1; i <= size(fac); i++){
            fac[i] = 0;
        }
        for(i = 0; i * den_vec[k] <= exp_degree; i++){
            fac[1 + i * den_vec[k] ] = 1;
        }
        E = polyProd(fac, E, exp_degree);
    }
    return(E);
}


static proc intvec2poly(bigintmat  vec){
    poly f = 0;
    poly t = var(1);
    for(int i = 1; i <= ncols(vec); i++){
        f = f + vec[1,i]*t^(i-1);
    }
    return(f);
}

static proc expandDenom(intvec den){
    poly g = 1;
    poly t = var(1);
    for(int i = 1; i <= size(den); i++){
            g = g*(1-t^den[i]);
    }
    return(g);
}

static proc unifiedRepresentations(EnumData HS_1, EnumData HS_2){

    ring T = 0,t,dp;
    poly num_1, den_1, num_2, den_2;
    num_1 = intvec2poly(HS_1.HilbertSeriesNum);
    num_2 = intvec2poly(HS_2.HilbertSeriesNum);
    den_1 = expandDenom(HS_1.HilbertSeriesDenom);
    den_2 = expandDenom(HS_2.HilbertSeriesDenom);
    if(num_1*den_2 == num_2*den_1){
        return(1);
    }
    return(0);
}

static proc fullDenomCCycloRatFunction(EnumData HS){
// transfer HS from denominator of cyclotomic polynomials p(e)
// to denominator with denominator of factors (1-t^e)

    ring T = 0,t,dp;
    poly factor;
    int expo;
    poly num_poly = intvec2poly(HS.HilbertSeriesNum);
    for(int i = 1; i <= size(HS.HilbertSeriesDenom); i++){
        expo = HS.HilbertSeriesDenom[i];
        factor = (1 -t^expo)/cyclotomic(expo);
        num_poly = num_poly * factor;
    }
    matrix C = coeffs(num_poly,t);
    bigintmat D[1][nrows(C)];
    for(i = 1; i<= nrows(C); i++){
        D[1,i] = bigint(C[i,1]);
    }
    HS.HilbertSeriesNum = D;
    return(HS);
}

static proc compareCCycloRatFunctions(EnumData HS_1, EnumData HS_2){
// Compares the expansions of rational functions as in cycloRatFunctionExpansion
// It must be made sure that the rational functions agree if and only they agree in
// numerator and denominator

    // if(HS_1.HilbertSeriesNum == HS_2.HilbertSeriesNum && HS_1.HilbertSeriesDenom == HS_2.HilbertSeriesDenom){
    //     return(-1,0);
    // }

    if(unifiedRepresentations(HS_1, HS_2) ){
         return(-1,0);
    }

    int expansion_deg = ncols(HS_1.HilbertSeriesNum);
    bigintmat expansion_1, expansion_2;
    int u;
    while(1)
    {
        expansion_1 = cycloRatFunctionExpansion(HS_1, expansion_deg);
        expansion_2 = cycloRatFunctionExpansion(HS_2, expansion_deg);
        if(expansion_1 == expansion_2){
            expansion_deg = 2*expansion_deg;
            continue;
        }
        for(u = 1; u <= expansion_deg+1; u++){
            if(expansion_1[1, u] != expansion_2[1, u]){
                return(u -1, expansion_1[1, u] - expansion_2[1, u])
            }
        }
    }
}

// ------------------------------------------------
// Computation of Hilbert series
//  -----------------------------------------------

// The return value is_normal registers whether monoid is normal
// in the nonnormal case the Markov basis is kept
// for use in tete-a-tete
static proc HilbertSeriesMonoid(intmat U, int min_degree){
// min_degree for output of Markovbasis
    intmat V;
    int swallow = setNmzOption("intclosed",1);
    V = normaliz(U, "monoid");
    exportNuminvs();
    // showNuminvs();
    swallow = setNmzOption("intclosed",0);
    int is_normal = nmz_integrally_closed;
    if(!is_normal){
        dbprint(our_printlevel,"Not normal");
        swallow = setNmzOption("MRK",1);
    }
    int saveBigNumInvs = BigNumInvs;
    BigNumInvs = 1;
    swallow = setNmzOption("only_hvect",1);
    if(Cyclotomic){
        swallow = setNmzOption("cyclo", 1);
    }
    else{
        swallow = setNmzOption("noquasi", 1);
    }
    // swallow = setNmzOption("verbose", 1);
    V = normaliz(U, "monoid", min_degree, "gb_min_degree");
    swallow = setNmzOption("only_hvect",0);
    swallow = setNmzOption("MRK",0);
    if(Cyclotomic){
        swallow = setNmzOption("cyclo", 0);
    }
    else{
        swallow = setNmzOption("noquasi", 0);
    }
    // swallow = setNmzOption("verbose", 0);
    exportNuminvs();
    BigNumInvs = saveBigNumInvs;
    EnumData HSeries;
    bigintmat Transfer;
    if(Cyclotomic){
        HSeries.HilbertSeriesDenom = nmz_hilbert_series_cyclo_denom;
        Transfer = nmz_hilbert_series_cyclo_num;
    }
    else{
        HSeries.HilbertSeriesDenom = nmz_hilbert_series_denom;
        Transfer = nmz_hilbert_series_num;
    }
    HSeries.HilbertSeriesNum = Transfer;
    if(Cyclotomic){
        HSeries = fullDenomCCycloRatFunction(HSeries);
    }

    return(HSeries, is_normal);
}

static proc HilbertSeriesMonAlgebra(ideal P, int min_degree)
{
    intmat U = mons2intmat(P);
    return (HilbertSeriesMonoid(U, min_degree));
}

// ------------------------------------------------
// Computation of Hilbert bases
//  -----------------------------------------------

static proc HilbertBasisMonoid(intmat U){
    intmat V;
    int swallow = setNmzOption("hilbbas",1);
    V = normaliz(U, "monoid");
    swallow = setNmzOption("hilbbas",0);
    return(V);
}

static proc HilbertBasisMonAlgebra(ideal P){
    intmat U = mons2intmat(P);
    return (intmat2mons(HilbertBasisMonoid(U)));
}

// ------------------------------------------------
// Subduction
//  -----------------------------------------------

static proc Subduction(ideal Pgiven, bigint nr_generators_needed){
// nr_generators = -1: complete subduction
// szbduction in the sense of Robbiano-Sweedler.
// It is applied once to every polynomial whose
// initial is not in the minimal system of generators of the algebra
// generated by the initial monomials
    ideal P = Pgiven;
    intvec test_num, test_den;
    int i,j;
    int swallow = setNmzOption("REP",1);
    intmat U = mons2intmat(P);
    intmat V = normaliz(U, "monoid"); // V only to swallow return value
    V = readNmzData("rep");
    swallow = setNmzOption("REP",0);
    exportNuminvs();

    bigint nr_generators = bigint(size(P) - nrows(V));
    string output = "polynomials " + string(size(P)) +  " minimal so far " + string( nr_generators);
    dbprint(our_printlevel,output);

    if(nr_generators_needed != -1 &&  nr_generators_needed == nr_generators){
        return(P, 0, nmz_hilbert_basis_key); // important here: no change in P anymore
    }                                        // can use  nmz_hilbert_basis_key
    if(nr_generators_needed == -1 &&  size(P) == nmz_hilbert_basis_elements){
        return(P, 0, nmz_hilbert_basis_key);
    }
   if(nr_generators_needed != -1 &&  size(P) == nmz_hilbert_basis_elements){
        ERROR("Error in Subduction. Inform the authors!");
    }
    // relative to Pgiven
    def our_ring = basering;
    int p = size(P);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1.. p)),dp;
    ideal Bl = intmat2binomials(V);
    setring our_ring;
    map f = S, P;
    ideal P_modify = f(Bl);
    for(i = 1; i <= nrows(V); i++){
        for(j= 1; j <= ncols(V); j++){
                if(V[i,j] == 1){
                        break;
                }
        }
        P[j] = P_modify[i];
    }
    ideal LC = leadcoafIdeal(P);
    intvec D = degIdeal(P);
    our_ring = basering;
    setring our_ring;
    P = removeConstants(P);
    P = simplify(P,1); // nakes monic
    int check = ncols(P);

    if(@do_def_ideal){
        setring @S;
        map g = S,@Retract;
        ideal Pre_modify = g(Bl);
        ideal LCC = fetch(our_ring, LC);
        for(i = 1; i <= nrows(V); i++){
            for(j= 1; j <= ncols(V); j++){
                    if(V[i,j] == 1){
                            break;
                    }
            }
            @Retract[j] = Pre_modify[i];
            if(D[j] <= 0){
                @DefIdeal = @DefIdeal, @Retract[j] - LCC[j];
                @Retract[j] = 0;
            }
            else{
                @Retract[j] = @Retract[j]/LCC[j];
            }
        }
        @Retract = simplify(@Retract, 2); // removes 0, DON'T MAKE MONIC
        if(check != ncols(@Retract)){
            "P ncols", check, " PreIm ncols ", ncols(@Retract);
            ERROR("Preimage doesn' fit. Inform the authors!");
        }
    }

    setring our_ring;
    return(P,1, nmz_hilbert_basis_key);
}

static proc HilbbasSubduction(ideal P, int old_nr_hilbbas, bigint HF_difference){
// Applies subduction as many times as necessary to frill HF_difference
    ideal Q = simplify(P, 3);
    int change;
    intvec HilbertBasisKey;

    bigint nr_generators_needed = bigint(old_nr_hilbbas) + HF_difference;
    string output = "Have " + string( old_nr_hilbbas) +  " need " + string(nr_generators_needed);
    dbprint(our_printlevel,output);

    while(1){
        (Q, change, HilbertBasisKey) = Subduction(Q, nr_generators_needed);
        if(change == 0){
            list L = sort(HilbertBasisKey);
            HilbertBasisKey = L[1];
            return(Q, HilbertBasisKey); // HilbertBasisKey only used in this case
        }
    }
}

static proc completeSubduction(ideal Q){
// applies subduction repeatedly until statbility is reached.
    int change;
    intvec HilbertBasisKey; // for syntactical reasons

    string output = "complete subduction applied to size "+ string(size(Q));
    dbprint(our_printlevel,output);
    while(1){
        (Q, change,HilbertBasisKey) = Subduction(Q, -1);
        if(change == 0){
            output = "subduced size " + string(size(Q));
            dbprint(our_printlevel,output);
            def our_ring = basering;
            if(@do_def_ideal){
                setring @S;
                output = "Size defining ideal so far (not minimized) " + string(size(@DefIdeal));
                dbprint(our_printlevel,output);
                setring our_ring;
            }
            return(Q);
        }
    }
}

// ------------------------------------------------
// Tete-a-tete
//  -----------------------------------------------

static proc Tete_A_TeteHilbControlled(ideal P, int crit_degree, int is_normal)
// Computes the terte-a-ztete of a system of polynomials (termonology of
// Robbiano-Sweedler). Control by Hilbert series: only the crit degree is
// evaluated and normalioty is exploited. General version below.
{
    dbprint(our_printlevel,"Start Tete-a-tete ");
    string output;

    // system("--ticks-per-sec",1000);
    // timer=0;
    // int t = timer;

    int i;
    ideal Q = P;
    Q = simplify(Q,3);

    // First we reconstruct the grading of the binomials
    // Only needed in the nonnormal case
    int GradingDenom = gradingDenominator(Q);
    intvec SGrad = gradVector(Q, GradingDenom);
    intmat U = mons2intmat(Q);

    // ideal Bla = lead(Q);
    // Bla;
    // mons2intmat(Bla);

    def our_ring = basering;
    int p = size(Q);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1..p)), dp;
    // U;
    intmat V;
    ideal B, Bfull;
    if(is_normal){ // in the normal case we don't have the Markov basis yet
        int swallow = setNmzOption("MRK",1);
        // swallow = setNmzOption("verbose",1);
        intmat Bl = normaliz(U, "monoid", crit_degree, "gb_min_degree", crit_degree, "gb_degree_bound");
        exportNuminvs();
        swallow = setNmzOption("MRK",0);
        // swallow = setNmzOption("verbose",0);
        V = readNmzData("mrk");
        dbprint(our_printlevel,"Evaluating tete-a-tete");
        output = "Computing " + string(nrows(V)) +  " binomials";
        dbprint(our_printlevel,output);
        B = intmat2binomials(V);
    }
    else{ // we have the full Markov basis already from the Hilbert series computation.
        // However we have the full Markov basis, and not a single degree only.
        // IMPORTANT::: we use the data of the Hilbert series computation
        // in this case.
        //

        int our_deg, u;
        V = readNmzData("mrk");
        dbprint(our_printlevel,"Evaluating tete-a-tete");
        // V;
        output = "Selecting from " + string(nrows(V)) + " binomials";
        dbprint(our_printlevel,output);
        Bfull = intmat2binomials(V);
        // "SSSSSSS ", size(leadexp(Bfull[1])), "   ", size(SGrad);
        B = selectionByDegree(Bfull, SGrad, crit_degree);
    }

    B = simplify(B,3);
    dbprint(our_printlevel,"Binomials computed");

    setring our_ring;
    map f =S, P;
    Q = Q, f(B);
    dbprint(our_printlevel,"Generators extended");
    Q =simplify(Q,3);
    // "Time in milliseconds ", timer-t;
    return(Q);
}

static proc Tete_A_TeteGeneral(ideal P, int current_degree, int Sagbi_degree_bound, int degreeByDegree, int makeNewTete_a_tete)
{

    int degree_tete_a_tete = -1;
    string output;
    // "Start Tete-a-tete ";
    // "current_degree ", current_degree;
    // "Sagbi_degree_bound ", Sagbi_degree_bound;
    // "degreeByDegree ", degreeByDegree;
    // "makeNewTete_a_tete ", makeNewTete_a_tete;
    // "startTete_tete", startTete_tete;
    if(makeNewTete_a_tete){
        dbprint(our_printlevel,"Making new tete-a-tete");
    }
    else{
        dbprint(our_printlevel,"Exploiting existing tete-a-tete");
    }
    ideal Q = P;
    intvec SGrad;
    if(degreeByDegree){
        int GradingDenom = gradingDenominator(Q);
        SGrad = gradVector(Q, GradingDenom);
    }

    intmat U = mons2intmat(Q);

    // ideal Bla = lead(Q);
    // Bla;

    def our_ring = basering;
    int p = size(Q);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1..p)), dp;
    // U;
    ideal B;

    int swallow = setNmzOption("MRK",1);
    intmat Dummy;
    if(current_degree != -1){
        if(degreeByDegree == 2){ // no jumping over empty degrees
            Dummy = normaliz(U, "monoid", current_degree, "gb_min_degree", current_degree, "gb_degree_bound");
                    exportNuminvs();
        }
        else{
            if(makeNewTete_a_tete){
                // U;
                // "---------------";
                // transpose(U);
                // "CCCCCCCCCCCCCCCCCC ",  current_degree;
                Dummy = normaliz(U, "monoid", current_degree, "gb_min_degree");
                // exportNuminvs();
                // showNuminvs();
            }
            // gb_degree_bound = -2 implies: print component d such that d >= gb_min_degree
            // and component is nonzero
            // Bl = normaliz(U, "monoid", current_degree, "gb_min_degree", -2, "gb_degree_bound");
        }
    }
    else{
        Dummy = normaliz(U, "monoid");
    }
    swallow = setNmzOption("MRK",0);

    intmat V;
    if(current_degree != -1){
        if(makeNewTete_a_tete){
            saveTete_a_tete =  readNmzData("mrk");
            startTete_tete = 1;
        }
        (V, startTete_tete) = selectNextDegree(saveTete_a_tete, startTete_tete, SGrad);
    }
    else{
        V = readNmzData("mrk");
    }

    int tete_a_tete_empty = 0;
    if(nrows(V) == 0){
        dbprint(our_printlevel,"Tete-a-tete empty");
        tete_a_tete_empty = 1;
    }
    dbprint(our_printlevel,"Evaluating tete-a-tete");
    output = "Computing " + string(nrows(V)) +  " binomials";
    dbprint(our_printlevel,output);
    B = intmat2binomials(V);
    dbprint(our_printlevel,"Binomials computed");
    int degree_too_large;
    degree_too_large = 0;
    if(degreeByDegree==1){
        degree_tete_a_tete = scalarProduct(leadexp(B[1]), SGrad);
        if(degree_tete_a_tete > Sagbi_degree_bound)
        {
            degree_too_large = 1;
        }
    }
    if(degreeByDegree==2){
        degree_tete_a_tete = current_degree;
    }
    B = simplify(B,3);
    setring our_ring;
    if(tete_a_tete_empty && degreeByDegree != 2){
        return(Q, -1);
    }
    if(degree_too_large){
        return(Q, degree_tete_a_tete);
    }
    map f =S, Q;
    Q = Q, f(B);
    dbprint(our_printlevel,"Generators extended");
    ideal LC = leadcoafIdeal(Q); // data needed for PreIm
    intvec D = degIdeal(Q);
    Q = removeConstants(Q);
    Q =simplify(Q,1);// makes monic
    int check = ncols(Q);

    if(@do_def_ideal){
        setring @S;
        map g = S,@Retract;
        @Retract = @Retract, g(B);
        ideal LCC = fetch(our_ring, LC);
        // aapplyLaedIdeal(LCC);
        preparePreIm(D, LCC);
        if(check != ncols(@Retract)){
            "Q ncols", check, " PreIm ncols ", ncols(@Retract);
            ERROR("Preimage doesn'tfit. Inform the authors!");
        }
    }
    setring our_ring;
    return(Q, degree_tete_a_tete);
}

// ------------------------------------------------
// Sagbi computation
//  -----------------------------------------------

static proc dosagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra,
                                  int Sagbi_degree_bound, int finalCheck, int sorting){
// The code would allow Sagbi_degree_bound = -, meaning no bound

    if(HS_denom_algebra[1] < 0){
        Cyclotomic = 1;
        HS_denom_algebra[1] = -HS_denom_algebra[1];
    }
    EnumData AlgebraHilbData;
    AlgebraHilbData.HilbertSeriesDenom = HS_denom_algebra;
    bigintmat Transfer[1][size(HS_num_algebra)];
    for(int i = 1; i <= size(HS_num_algebra); i++){
        Transfer[1,i] = HS_num_algebra[i];
    }
    AlgebraHilbData.HilbertSeriesNum = Transfer;
    if(Cyclotomic){
        AlgebraHilbData = fullDenomCCycloRatFunction(AlgebraHilbData);
    }

    int has_positive_degree = 0;
    for(int i = 1; i <= ncols(Q); i++){
        if(deg(Q[i]) >= 1){
            has_positive_degree = 1;
            break;
        }
    }
    if(!has_positive_degree){
        ERROR("At least one generator must have positive degree");
    }
    string output;

    int crit_degree, nr_hilbbas_1, nr_hilbbas_2;
    bigint HF_difference;
    ideal Plow, Phigh, K, Dummy;
    intvec HS_denom_cand, HS_num_cand;
    int GradingDenom, standard_crit_degree;
    intvec HilbertBasisKey;

    ideal P = simplify(Q,15); // make inititial coeff 1, erase 0, duplicates and scalar multiples
    P = completeSubduction(P);
    dbprint(our_printlevel,"Initial subduction dione");

    GradingDenom = gradingDenominator(P);
    int round = 0;
    int count;
    intmat U,V;
    int swallow;
    int is_normal;

    list L;

    crit_degree = 0;

    EnumData CandData;


    while(1){
        if(round > 0){
            output = "New Hilbert series " + string(round);
           dbprint(our_printlevel,output);
        }

        if(sorting){
            L = sort(P,"dp");
            P = L[1];
        }
        (CandData, is_normal) = HilbertSeriesMonAlgebra(P, crit_degree+1);

        // (HS_num_cand, HS_denom_cand, is_normal) = HilbertSeriesMonAlgebra(P, crit_degree+1);

        (crit_degree, HF_difference) = compareCCycloRatFunctions(AlgebraHilbData, CandData);


        //(crit_degree, HF_difference) = compareCCycloRatFunctions(HS_num_algebra, HS_denom_algebra,
        //                 HS_num_cand, HS_denom_cand);

        // quit;

        if(crit_degree > Sagbi_degree_bound && Sagbi_degree_bound != -1){
        output =  "critical degree = " + string(crit_degree) +  " > Sagbi_degree_bound = " + string(Sagbi_degree_bound);
            dbprint(our_printlevel,"--------------------------------------------------------------");
            return(P,0):
        }

        if(crit_degree == -1){
            if(round > 0){
                dbprint(our_printlevel,"Sagbi basis computed");
                dbprint(our_printlevel,"--------------------------------------------------------------");
            }
            return(P,2);
        }
        if(round == 0){
            dbprint(our_printlevel,"--------------------------------------------------------------");
        }
        else{
            dbprint(our_printlevel,"*********************");
        }
        round++;

        // "got Hilbert series ", HS_num_cand, "  ", HS_denom_cand;
        if(round == 1){
            output = "expected Hilbert series with representation " + string(HS_num_algebra)  + "   " + string( HS_denom_algebra);
            dbprint(our_printlevel,output);
        }
        output = "crit_degree " + string(crit_degree) + ": HF_difference " + string( HF_difference);
        dbprint(our_printlevel,output);

        // we must split our algebra generators at the critical degree
        Plow = 0;
        Phigh = 0;
        standard_crit_degree = crit_degree * GradingDenom;
        for(i = 1; i <=size(P); i++){
            if(deg(P[i])  <= standard_crit_degree){
                Plow = Plow + P[i];
            }
            else{
                Phigh = Phigh + P[i];
            }
        }
        Dummy = HilbertBasisMonAlgebra(Plow);
        nr_hilbbas_1 = size(Dummy);

        K= Tete_A_TeteHilbControlled(Plow, crit_degree,is_normal);
        dbprint(our_printlevel,"Tete-a-tete done");
        (K, HilbertBasisKey) = HilbbasSubduction(K, nr_hilbbas_1, HF_difference);
        dbprint(our_printlevel,"Subduction done");

        P = 0;
        for(i = 1; i <= size( HilbertBasisKey); i++){
            P = P + K[ HilbertBasisKey[i]];
        }

        if(crit_degree >= Sagbi_degree_bound && Sagbi_degree_bound != -1 && !finalCheck){
            output = "Sagbi basis computed up tp degree " + string(Sagbi_degree_bound);
            dbprint(our_printlevel,output);
            dbprint(our_printlevel,"No final check");
            return(P,1);
        }

        if(size(Phigh) > 0){
            P = P + Phigh;
            P = completeSubduction(P);
        }

        // lead(P);
    }
}
// ---------------------------------------------------------------

static proc doSagbiGeneral(ideal Q, int defining_ideal, int Sagbi_degree_bound, int Sagbi_max_rounds, int sorting)
{
    int i;
    int has_positive_degree = 0;
    for(i = 1; i <= ncols(Q); i++){
        if(deg(Q[i]) >= 1){
            has_positive_degree = 1;
            break;
        }
    }
    if(!has_positive_degree){
        ERROR("At least one generator must have positive degree");
    }


    string output;

    int degreeByDegree = 0;
    if(Sagbi_degree_bound != -1){
        degreeByDegree = 1;
    }

    // if(degreeByDegree == 0 && defining_ideal == 1){
    //     ERROR("Defining ideal only computed gegree by degree");
    // }

    @do_def_ideal = defining_ideal;

    ideal P;
    int GradingDenom;
    intvec D;

    def our_ring = basering;

    if(!@do_def_ideal){
        Q = removeConstants(Q); // erases constants including 0
        P = simplify(Q,13); // make inititial coeff 1,  remove duplicates and scalar multiples
    }
    else{
        // setup preimages of generators, take care of constants in the generators (not forbidden)
        // constants give elements in the defining ideal
        P = Q;
        ideal LC = leadcoafIdeal(P); // must be done before any change of P
        D = degIdeal(P);      // ditto. We need hese data for PreIm
        for(i = 1; i <=size(D); i++){
            if(D[i] <= 0){
                ERROR("constants not allowed in algebra generators");
            }
        }
        // "Degrees ", D, " LC ", LC;
        list baseringlist = ringlist(basering);
        int p = ncols(P);
        P = removeConstants(P); // PreIm will be gtaken care below
        P = simplify(P,1); // make monic
        ring @S = (baseringlist[1]),(y(1.. p)),wp(D);
        ideal @Retract =(y(1..p));
        ideal @DefIdeal;
        ideal @Retract_low;
        ideal @Retract_high;
        export(@S);
        export(@Retract);
        export(@DefIdeal);
        export(@Retract_low);
        export(@Retract_high);
        ideal LCC = fetch(our_ring, LC);
        preparePreIm(D, LCC); // takes care of constants in P, makes moic
        // for(i = 1; i <= ncols(LCC); i++){
        //             @Retract[i] = @Retract[i]/LCC[i];
        // }
        setring our_ring;
    }

    GradingDenom = gradingDenominator(P);

    P = completeSubduction(P);
    dbprint(our_printlevel,"Initial subduction dione");

    int maxDegreeGens = deg(P[1]);
    int minDegreeGens = maxDegreeGens;
    for(i = 2; i <= size(P); i++){
        if(deg(P[i]) > maxDegreeGens){
            maxDegreeGens = deg(P[i]);
        }
        if(deg(P[i]) < minDegreeGens){
            minDegreeGens = deg(P[i]);
        }
    }
    maxDegreeGens = maxDegreeGens div GradingDenom;
    minDegreeGens = minDegreeGens div GradingDenom;


    ideal P_1;
    int done;
    int checked;
    int makeNewTete_a_tete = 1;
    int first_after_maxDegGens = 1;

    int uu = minDegreeGens;
    int degreeBoundReached;
    list L;

    int degree_tete_a_tete;

    ideal Plow, Phigh;
    int round = 1;
    int check_high,check_low;

    while(1){
        P = simplify(P,3);
        if(sorting){
            L = sort(P, "dp");
            P = L[1];
        }

        Plow = 0;
        Phigh = 0;
        our_ring = basering;

        if(@do_def_ideal){
            setring @S;
            @Retract_high = 0;
            @Retract_low = 0;
        }

        setring our_ring;

        if(!degreeByDegree){
            (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(P, -1, -1, 0,1);
            P_1 = completeSubduction(P_1);
        }
        else{
            if(uu < maxDegreeGens){
                our_ring = basering;
                D = degIdeal(P);
                for(i = 1; i <=size(P); i++){
                    if(D[i] <= uu * GradingDenom){
                        Plow = Plow + P[i];
                    }
                    else{
                        Phigh = Phigh + P[i];
                    }
                }
                check_low = size(Plow);
                check_high = size(Phigh);
                if(@do_def_ideal){
                    setring @S;
                    for(i = 1; i <=size(D); i++){
                        if(D[i] <= uu * GradingDenom){
                            @Retract_low = @Retract_low + @Retract[i];
                        }
                        else{
                            @Retract_high = @Retract_high + @Retract[i];
                        }
                    }
                    if(size(@Retract_low) != check_low || size(@Retract_high) != check_high){
                      "Problem ", size(@Retract_low), check_low, size(@Retract_high), check_high;
                    }
                    @Retract = @Retract_low;
                }
                setring our_ring;
                // 2 = strictly degree by degree
                (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(Plow,uu, Sagbi_degree_bound, 2, 1);
            }
            else{
                (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(P,uu, Sagbi_degree_bound, 1, makeNewTete_a_tete);
            }
            if(degree_tete_a_tete == -1){
                our_ring = basering;
                dbprint(our_printlevel,"Sagbi basis computed");
                if(@do_def_ideal){
                    setring @S;
                    @DefIdeal = simplify(@DefIdeal, 3);
                }
                setring our_ring;
                if(@do_def_ideal){
                    checkDefIdeal(Q);
                }
                return(P_1,2);
            }
            if(uu !=  degree_tete_a_tete){
                if(uu > degree_tete_a_tete){
                    ERROR("Degree in tete-a-tete too small. Inform the authors!");
                }
                uu = degree_tete_a_tete;
                if(uu > Sagbi_degree_bound){
                    dbprint(our_printlevel,"Degree bound reached");
                    if(@do_def_ideal){
                        setring @S;
                        @DefIdeal = simplify(@DefIdeal, 3);
                    }
                    setring our_ring;
                    if(@do_def_ideal){
                        checkDefIdeal(Q);
                    }
                    return(P_1, 1);
                }
                output = "Degree increased to " + string( uu);
                dbprint(our_printlevel,output);
            }
            P_1 = completeSubduction(P_1);
        }

        degreeBoundReached = 0;
        if(Sagbi_degree_bound == uu){
            degreeBoundReached = 1;
        }

        if(degreeBoundReached){
            dbprint(our_printlevel,"Degree bound reached");
            if(@do_def_ideal){
                setring @S;
                @DefIdeal = simplify(@DefIdeal, 3);
            }
            setring our_ring;
            if(@do_def_ideal){
                checkDefIdeal(Q);
            }
            return(P_1,1);
        }

        done = 0;
        checked = 0;
        if(size(P) == size(P_1) && !degreeByDegree){
            done = 1;
            checked = 1;
            for(i = 1; i <= size(P); i++){
                if(P[i] != P_1[i]){
                    done = 0;
                    break;
                }
            }
        }

        if(done){
            dbprint(our_printlevel,"Sagbi basis computed");
            if(@do_def_ideal){
                our_ring = basering;
                setring @S;
                @DefIdeal = simplify(@DefIdeal, 3);
                setring our_ring;
                checkDefIdeal(Q);
            }
            return(P_1, 2);
        }

        round++;
        if(Sagbi_max_rounds != -1 && round > Sagbi_max_rounds){
            dbprint(our_printlevel,"Maximal number of rounds reached");
            return(P_1,1);
        }

        uu++;
        dbprint(our_printlevel,"*********************");
        output = "Round " + string( round) + " with " + string(size(P_1)) + " generators";
        dbprint(our_printlevel,output);
        if(degreeByDegree){
            output = "Degree >= " + string(uu);
            dbprint(our_printlevel, output);
        }

        if(degreeByDegree){
            makeNewTete_a_tete = 0;
            if(size(P) != size(P_1)){
                makeNewTete_a_tete = 1;
            }
            else{
                if(minDegreeGens < maxDegreeGens){ // in this case we may have P != P_1 despite of equal size
                    for(i = size(P); i >= 1; i--){
                        if(P[i] != P_1[i]){
                            makeNewTete_a_tete = 1;
                            break;
                        }
                    }
                }
            }
        }

        P = P_1 + Phigh;
        our_ring = basering;
        if(@do_def_ideal){
            setring @S;
            @Retract = @Retract + @Retract_high;
        }

        setring our_ring;

     } // main while loop

}

// ------------------------------------------------
// User interface
//  -----------------------------------------------

proc sagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound, list #)
"USAGE:   agbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound [,int finalChweck, int sorting, int verb]);
RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials inin degrwees <= Sagbi_degree_bound. The computation is controlled by the Hilbert series
          given by the numerator and the denominator.

          If sorting is set, the  computed elements are degrevlex sorted before a round of the algorithm.
          The optional parameter verb sets the terminal output. Default is 1 = on.

          The return value has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.

EXAMPLE:  example sagbiHilbControlled; shows an example
"
{

    int finalCheck = 0;
    int sorting = 0;

    if(size(#) > 0){
        finalCheck = #[1];
    }
    if(size(#) > 1){
        sorting = #[2];
    }
    if(size(#) > 2){
        our_printlevel = #[3];
    }

    if(Sagbi_degree_bound <= 0){
        ERROR("Degree bound must be positive");
    }

    if(!homog(Q)){
            ERROR("sagbiHilbControlled expects homogeneous input");
    }
    list baseringlist = ringlist(basering);
    intvec w = baseringlist[3][1][2];
    for(int i = 1; i <=size(w); i++){
        if(w[i] !=  1){
            ERROR("Basering not standard graded");
        }
    }

    ideal P;
    int success;
    (P, success) = dosagbiHilbControlled(Q, HS_num_algebra, HS_denom_algebra, Sagbi_degree_bound, finalCheck, sorting);
    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7, x^8+y^8+z^8;
    ideal Q;
    intvec HS_num = 1;
    intvec HS_denom = 6,7,8;
    int success;
    // degree bound 40, final check, ,no sorting, no terminal output
    (Q,success) = sagbiHilbControlled(P,HS_num, HS_denom,40, 1,0,0);
    lead(Q);
    "Note: success = 0 <==> Sagbi basis incomplete";
    "success",success;
}


proc sagbiByDegree(ideal Q, int Sagbi_degree_bound, list #)
"USAGE:   sagbiByDegree(ideal Q, int sagbiDegreeBound [,int sorting, int verb]);
RETURN:   RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials inin degrwees <= Sagbi_degree_bound.

          If sorting is set, the  computed elements are degrevlex sorted before a round of the algorithm.
          The optional parameter verb sets the terminal output. Default is 1 = on.

          The return value has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.

EXAMPLE:  example sagbiByDegree; shows an example
"
{
    int sorting = 0;
    if(size(#) > 0)
    {
        sorting = #[1];
    }
    if(size(#) > 1){
        our_printlevel = #[2];
    }


    if(Sagbi_degree_bound <= 0){
        ERROR("Degree bound must be positive");
    }
    if(!homog(Q)){
            ERROR("sagbiByDegree expects homogeneous input");
    }

    list baseringlist = ringlist(basering);
    intvec w = baseringlist[3][1][2];
    for(int i = 1; i <=size(w); i++){
        if(w[i] !=  1){
            ERROR("Basering not standard graded");
        }
    }

    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, 0, Sagbi_degree_bound, -1, sorting);

    int NrTerms = 0;
    for(int k = 1; k <= size(P); k++){
            NrTerms = NrTerms + size(P[k]);
    }
    // "Number Terms", NrTerms;


    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7, x^8+y^8+z^8;
    ideal Q;
    int success;
    // degree bound 40, no sorting, no terminal output
    (Q,success) = sagbiByDegree(P,40,0,0);
    lead(Q);
    "Note: success = 1 <==> Unknown whether complete";
    "success",success;
}


proc sagbiGeneral(ideal Q, list #)
"USAGE:   sagbiGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]));
RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials in Q as far as computwed in at most sagbiMaxRounds.

          If sorting is set, the  computed elements are degrevlex sorted before a round of the algorithm.
          The optional parameter verb sets the terminal output. Default is 1 = on.

          The return value has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.

EXAMPLE:  example agbiGeneral; shows an example
"
{
    int sorting = 0;
    int Sagbi_max_rounds = -1;
    if(size(#) > 0){
        Sagbi_max_rounds = #[1];
    }
    if(size(#) > 1){
        sorting = #[2];
    }
    if(size(#) > 2){
        our_printlevel = #[3];
    }
    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, 0, -1, Sagbi_max_rounds, sorting);
    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7;
    ideal Q;
    int success;
    // at most 3 rounds, no sorting, no terminal output
    (Q,success) = sagbiGeneral(P,3,0,0);
     Q;
    "Note: success = 2 <==> Sagbi basis complete";
    "success",success;
}

proc sagbiDefIdealByDegree(ideal Q, int Sagbi_degree_bound, list #)
"USAGE:   defIdealByDegree(ideal Q, int sagbiDegreeBound [,int sorting, int verb]);
RETURN:   An instance of

          newstruct("sagbiResult","int success, ideal sagbiBasis, ideal defIdeal,, ideal retract");

          success has the value 0, if the full Sagbi basis has not been reached,
          1 if this is unknown, and 2 if the full Sagbi basis has been computed.

          sagbiBasis is the Sagbi basis encodeed as an ideal in the polynomial ring that was
          active when sagbiDefIdealByDegree was called.

          defIdeal contains the defining ideal and the retract (as far as computed). They live in the ring
          (name of the result).r_defIdeal; See example for the activation of this ring.
          The defining ideal has been minimized.

          Note: sorting, if set at all, must be 0.

EXAMPLE:  example sagbiDefIdealByDegree; shows an example
"
{
    // checkPposDegree(Q);

    int sorting = 0;
     if(size(#) > 1){
        sorting = #[2];
    }
    if(sorting){
        "Sorting not allowed for defining ideal and swiched off";
        sorting = 0;
    }

    if(size(#) > 1){
        our_printlevel = #[2];
    }

    if(Sagbi_degree_bound <= 0){
        ERROR("Degree bound must be positive");
    }
    if(!homog(Q)){
            ERROR("defIdealByDegree expects homogeneous input");
    }

    list baseringlist = ringlist(basering);
    intvec w = baseringlist[3][1][2];
    for(int i = 1; i <=size(w); i++){
        if(w[i] !=  1){
            ERROR("Basering not standard graded");
        }
    }

    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, 1, Sagbi_degree_bound, -1, sorting); // 1 = defining ideal

    // int NrTerms = 0;
    // for(int k = 1; k <= size(P); k++){
    //        NrTerms = NrTerms + size(P[k]);
    // }
    // "Number Terms", NrTerms;

    sagbiResult res;
    res.success = success;
    res.sagbiBasis = P;
    def our_ring = basering;
    setring @S;
    res.defIdeal = minbase(@DefIdeal);
    res.retract = @Retract;
    setring our_ring;
    return(res);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0,(x(1..2)(1..5)), dp;
    matrix M[2][5] = x(1..2)(1..5);
    ideal P = minor(M,2);
    int degree_bound = 15;
    def Result = sagbiDefIdealByDegree(P, degree_bound, 0, 1);
    "Note: success = 2 <==> Sagbi basis and defining ideal completee";
    "success", Result.success;
    "Sagbi basis";
    Result.sagbiBasis;
    def motherRing = Result.r_defIdeal;
    setring motherRing;
    "defining ideal";
    Result.defIdeal;
    "retract";
    Result.retract;
}

proc sagbiDefIdealGeneral(ideal Q, list #)
"USAGE:   defIdealGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]));
RETURN:    An instance of

          newstruct("sagbiResult","int success, ideal sagbiBasis, ideal defIdeal, ideal retract");

          success has the value 0, if the full Sagbi basis has not been reached,
          1 if this is unknown, and 2 if the full Sagbi basis has been computed.

          sagbiBasis is the Sagbi basis encodeed as an ideal in the polynomial ring that was
          active when sagbiDefIdealByDegree was called.

          defIdeal contains the defining ideal and the retract (as far as computed). They live in the ring
          (name of the result).r_defIdeal; See example for the activation of this ring.
          The defining ideal has been minimized.

          Note: sorting, if set at all, must be 0.

EXAMPLE:  example sagbiDefIdealGeneral; shows an example
"
{
    int sorting = 0;
    int Sagbi_max_rounds = -1;
    if(size(#) > 0){
        Sagbi_max_rounds = #[1];
    }
    if(size(#) > 1){
        sorting = #[2];
    }
    if(sorting){
        "Sorting not allowed for defining ideal and swiched off";
        sorting = 0;
    }
    if(size(#) > 2){
        our_printlevel = #[3];
    }
    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, 1, -1, Sagbi_max_rounds, sorting); // 1 = defining ideal, -1 = no degrees.

    sagbiResult res;
    res.success = success;
    res.sagbiBasis = P;
    def our_ring = basering;
    setring @S;
    res.defIdeal = @DefIdeal;
    res.retract = @Retract;
    setring our_ring;
    return(res);
}
example
{ "EXAMPLE:";echo=2;
    ring R = 0,(x,w),dp;
    ideal A = x^2-w+1, x + w^3, x -w;
    def Result = sagbiDefIdealGeneral(A,-1);    "Note: success = 2 <==> Sagbi basis and defining ideal completee";
    "success", Result.success;
    "Sagbi basis";
    Result.sagbiBasis;
    def motherRing = Result.r_defIdeal;
    setring motherRing;
    "defining ideal";
    Result.defIdeal;
    "retract";
    Result.retract;
}
// ------------------------------------------------
// Initialization
//  -----------------------------------------------

static proc mod_init()
{
    LIB "normaliz.lib";
    LIB "finvar.lib";
    int swallow;
    addNmzOption("MRK","MarkovBasis");
    addNmzOption("REP","Representations");
    addNmzOption("BPK","BinomialsPacked");
    addNmzOption("cyclo","OnlyCyclotomicHilbSer");
    swallow =addNmzOption("noquasi","NoQuasiPolynomial");
    swallow = setNmzOption("BPK", 1);
    swallow = setNmzOption("MRK",0);
    swallow =setNmzOption("REP",0);
    swallow =setNmzOption("cyclo",0);
    swallow =setNmzOption("noquasi",0);
    setNmzFilename("NmzSagbiExchange");
    intmat saveTete_a_tete;
    int startTete_tete;
    export(saveTete_a_tete);
    export(startTete_tete);
    int our_printlevel = 1;
    export(our_printlevel);
    int @do_def_ideal = 0;
    export(@do_def_ideal);
    newstruct("EnumData", "bigintmat HilbertSeriesNum, intvec HilbertSeriesDenom, bigint MultiplicityNum, bigint NultiplicityDenom");
    newstruct("GradingData", "int GradingDenom, intvec GradingVec");
    newstruct("sagbiResult","int success, ideal sagbiBasis, ideal defIdeal, ideal retract");
    int Cyclotomic = 0;
    export(Cyclotomic);
}

