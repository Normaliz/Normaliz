% !TeX spellcheck = en_US

\section{Computation goals and algorithmic variants}\label{Goals}

The library \verb|libnormaliz| contains a class \verb|ConeProperties| that collects computation goals, algorithmic variants and additional data that are used to control the work flow in \verb|libnormaliz| as well as the communication with other programs. The latter are not important for the Normaliz user, but are listed as a reference for \verb|libnormaliz|. See Appendix~\ref{libnorm} for a description of \verb|libnormaliz|.

All computation goals and algorithmic variants can be communicated to Normaliz in two ways:
\begin{arab}
	\item in the input file, for example \verb|HilbertBasis|,
	\item via a verbatim command line option, for example \verb|--HilbertBasis|.
\end{arab}
For the most important choices there are single letter command line options, for example \verb|-N| for \verb|HilbertBasis|. The single letter options ensure backward compatibility to Normaliz~2. In jNormaliz they are also accessible via their full names.

Some computation goals apply only to homogeneous computations, and some others make sense only for inhomogeneous computations.

Some single letter command line options combine two or more computation goals, and some algorithmic variants imply computation goals.

There are restrictions for algebraic polyhedra. See Section~\ref{alg_comp}.

\subsection{Default choices and basic rules}

If several computation goals are set, all of them are pursued. In particular, computation goals in the input file and on the command line are accumulated. But
\begin{itemize}
	\itemtt[-{}-ignore, -i] on the command line switches off the computation goals and algorithmic variants set in the input file.
\end{itemize}

The default computation goal is set if neither the input file nor the command line contains a computation goal or an algorithmic variant that implies a computation goal. The deafault computatin goal depends on the input type.
\begin{itemize}
	\item Except the input of a monoid or binomial ideal it is
	\begin{center}
		\verb|SupportHyperplanes| + \verb|HilbertBasis| + \verb|HilbertSeries| .
	\end{center}
	In the homogeneous case, \verb|ClassGroup| is included as well.
	
	\item For \verb|monoid|, \verb|toric_ideal| and \verb|normal_toric _ideal| it is \verb|HilbertBasis| + \verb|IsIntegrallyClosed| for the momnoid derived from them.
	
	\item  For the input type \verb|lattice_ideal| it is  \verb|MarkovBasis|.
\end{itemize}

If set explicitly in the input file or on the command line the following adds these computation goals:
\begin{itemize}
	\itemtt[DefaultMode]
\end{itemize}

\verb|DefaultMode| can be set explicitly in addition to other computation goals. If it is set, implicitly or explicitly, Normaliz will not complain about unreachable computation goals.

\subsection{Computation goals}\label{goals}

Almost always the computation goals set explicitly or by default require the comoputation of auxiliary data that themselves can be asked for by explicit computation goals. In most cases the results of these computations appear in the output. In case of doubt set exlicit computation goals.

\subsubsection{Lattice data}

\begin{itemize}
	\itemtt[Sublattice, -S] (upper case S) asks Normaliz to compute the coordinate transformation to and from the efficient sublattice.
\end{itemize}

\subsubsection{Support hyperplanes and extreme rays}

\begin{itemize}
	\itemtt[SupportHyperplanes, -s] triggers the computation of support hyperplanes and extreme rays.
\end{itemize}

Normaliz tries to find a grading in the homogeneous case.

\begin{itemize}
	\itemtt[VerticesFloat] converts the format of the vertices to floating point. It implies \texttt{SupportHyperplanes}.
	\itemtt[SuppHypsFloat] converts the format of the support hyperplanes to floating point. It implies \texttt{SupportHyperplanes}.
	\itemtt[ExtremeRaysFloat] does the same for the extreme rays.
\end{itemize}

Note that \texttt{VerticesFloat} and \texttt{SuppHypsFloat} are not pure output options. They are computation goals, and therefore break implicit \texttt{DefaultMode}.

\begin{itemize}
	\itemtt[ProjectCone] Normaliz projects the cone defined by the input data onto a subspace generated by selected coordinate vectors and computes the image with the goal \verb|SupportHyperplanes|.
\end{itemize}


\subsubsection{Hilbert basis and lattice points}

\begin{itemize}
	
	\itemtt[HilbertBasis, -N] triggers the computation of the Hilbert basis. In inhomogeneous computations it asks for the Hilbert basis of the recession monoid \emph{and} the module generators.
	
	\itemtt [WitnessNotIntegrallyClosed, -w] With this option, Normaliz stops the Hilbert basis computation as soon it has found a witness confirming that the original monoid is not integrally closed.
	
	\itemtt[Deg1Elements, -1] restricts the computation to the degree $1$ elements of the Hilbert basis in homogeneous computations (where it requires the presence of a grading).
	
	\itemtt[LatticePoints] is identical to \verb|Deg1Elements| in the homogeneous case, but implies \verb|NoGradingDenom|. In inhomogeneous computations it is a synonym for \verb|HilbertBasis|.
	
	\itemtt[SingleLatticePoint] stops the computation once a lattice point has been found. Forces the project-and-lift algorithm.
	
	\itemtt[ModuleGeneratorsOverOriginalMonoid, -M] computes a minimal system of generators of the integral closure over the original monoid (see Section~\ref{MinMod}). Requires the existence of original monoid generators.
\end{itemize}

The boolean valued computation goal \verb|IsIntegrallyClosed| is also related to the Hilbert basis; see Section~\ref{bool}.

\subsubsection{Enumerative data}

The computation goals in this section require a grading. They include \verb|SupportHyperplanes|.

\begin{itemize}
	\itemtt [HilbertSeries,-q] triggers the computation of the Hilbert series.
	
	\itemtt[EhrhartSeries] computes the Ehrhart series of a polytope, regardless of whether it is defined by homogeneous or inhomogeneous input. In the homogeneous case it is equivalent to \verb|HilbertSeries| + \verb|NoGradingDenom|, but not in the inhomogeneous case. See the discussion in Section~\ref{Polytopes}. Can be combined with \verb|HSOP|.
	
	\itemtt[Multiplicity, -v] restricts the computation to the multiplicity.
	
	\itemtt[Volume, -V] computes the lattice normalized and the Euclidean volume of a polytope given by homogeneous or inhomogeneous input (implies \verb|Multiplicity| in the homogeneous case, but also sets \verb|NoGradingDenom|).
	
	\itemtt[HSOP] lets Normaliz compute the degrees in a homogeneous system of parameters and the induced representation of the Hilbert or Ehrhart series series. Note that \ttt{HSOP} does not imply \ttt{HilbertSeries} or \ttt{EhrhartSeries}.
	
	\itemtt[NoPeriodBound] This option removes the period bound that Normaliz sets for the computation of the Hilbert quasipolynomial (presently $10^6$).
	
	\itemtt[NumberLatticePoints] finds the number of lattice points. They are not stored.
\end{itemize}

\subsubsection{Combined computation goals}

Can only be set by single letter command line options:

\begin{itemize}
	\itemtt[-n] \verb|HilbertBasis| + \verb|Multiplicity|
	
	\itemtt[-h] \verb|HilbertBasis| + \verb|HilbertSeries|
	
	\itemtt[-p] \verb|Deg1Elements| + \verb|HilbertSeries|
	
\end{itemize}

\subsubsection{The class group}

\begin{itemize}
	\itemtt [ClassGroup, -C] is self explanatory, includes \verb|SupportHyperplanes|. Not allowed in inhomogeneous computations.
\end{itemize}

\subsubsection{Integer hull}

\begin{itemize}
	\itemtt [IntegerHull, -H] computes the integer hull of a polyhedron. Implies the computation of the lattice points in it.
\end{itemize}

More precisely: in homogeneous computations it implies \verb|Deg1Elements|, in inhomogeneous computations it implies \verb|HilbertBasis|. See Section~\ref{IntHull}.

\subsubsection{Triangulation and Stanley decomposition}

\begin{itemize}
	
	\itemtt[Triangulation, -T] makes Normaliz compute, store and export the full triangulation.
	
	\itemtt[ConeDecomposition, -D] Normaliz computes a disjoint decomposition of the cone into semiopen simplicial cones. Implies \verb|Triangulation|.
	
	\itemtt[TriangulationSize, -t] makes Normaliz count the simplicial cones in the full triangulation.
	
	\itemtt[TriangulationDetSum] makes Normaliz additionally sum the absolute values of their determinants.
	
	\itemtt[StanleyDec, -y] makes Normaliz compute, store and export the Stanley decomposition.
	
	\itemtt[AllGeneratorsTriangulation] makes Normaliz compute and store a triangulation that uses all generators.
	
	\itemtt[LatticePointTriangulation] makes Normaliz compute and store a triangulation that uses all lattice points in a polytope.
	
	\itemtt[UnimodularTriangulation] makes Normaliz compute and store a unimodular triangulation.
	
\end{itemize}

The triangulation and the Stanley decomposition are treated
separately since they can become very large and may exhaust
memory if they must be stored for output.

Note that these decompositions cannot be computed for a polyhedron that is unbounded (modulo its maximal subspace). However, they are allowed for polytopes defined by inhomogeneous input. \verb|UnimodularTriangulation| is only allowed in homogeneous computations and is excluded for algebraic polyhedra.

The following triangulations are defined by the order of the generators. See SEctions \ref{PlacingTri} and \ref{PullingTri}.
\begin{itemize}
	\itemtt[PlacingTriangulation]
	\itemtt[PullingTriangulation]
\end{itemize}

\subsubsection{Face structure}

The f-vector of a polyhedron is computed by
\begin{itemize}
	\itemtt[FVector]
\end{itemize}

The set of faces of a polyhedron is computed by
\begin{itemize}
	\itemtt[FaceLattice]
\end{itemize}
Like the triangulation or Stanley decomposition the face lattice can become very large, and it is already computed with \ttt{FVector}. \ttt{FaceLattice} writes an extra output file. The details of its representation in the extra output file are discussed in Section~\ref{FaceLattice}.

The face lattice computation is based on the incidence vectors of the facets. It is possible to retrieve this matrix (independently of \verb|FVector| or \verb|FaceLattice|) via the computation goal
\begin{itemize}
	\itemtt[Incidence]
\end{itemize}
Section~\ref{FaceLattice} as well. See it also for the dual versions
\begin{itemize}
	\itemtt[DualFVector]
	\itemtt[DualFaceLattice]
	\itemtt[DualIncidence]
\end{itemize}

For computation of orbits we have

\begin{itemize}
	\itemtt[FVectorOrbits]
	\itemtt[FaceLatticeOrbits]
	\itemtt[DualFVectorOrbits]
	\itemtt[DualFaceLatticeOrbits]
\end{itemize}

\subsubsection{Semiopen polyhedra}

\begin{itemize}
	\itemtt[IsEmptySemiopen]
\end{itemize}

asks for the emptiness of a semiopen polyhedron. See Section~\ref{semi_open}.


\subsubsection{Automorphism groups}

Automorphism groups are defined in Section~\ref{Automorphisms}.
\begin{itemize}
	\itemtt[Automorphisms] computes the integral automorphisms of rational polyhedra and the algebraic automorphisms of algebraic polytopes.
	
	\itemtt [RationalAutomorphisms] computes the rational automorphisms of rational polytopes.
	
	\itemtt[EuclideanAutomorphisms] computes the euclidean automorphisms of rational and algebraic polytopes.
	
	\itemtt [CombinatorialAutomorphisms] computes ate combinatorial automorphisms of polyhedra.
	
	\itemtt[AmbientAutomorphisms] computes automorphisms induce by permutations of coordinates of the ambient space.
	
	\itemtt[InputAutomorphisms] computes taional (or algebraic) automorphisms based solely on the input and initial coordinate transformations.
\end{itemize}

\subsubsection{Weighted Ehrhart series and integrals}

\begin{itemize}
	
	\itemtt[WeightedEhrhartSeries, -E] makes Normaliz compute a generalized Ehrhart series.
	
	\itemtt[VirtualMultiplicity, -L] makes Normaliz compute the virtual multiplicity of a weighted Ehrhart series.
	
	\itemtt[Integral, -I] makes Normaliz compute an integral over a polytope. Implies \verb|NoGradingDenom|.
\end{itemize}

These computation goals require a homogeneous computation.

Don't confuse these options with symmetrization. The latter symmetrizes (if possible) the given data and uses \verb|-E| or \verb|-L| internally on the symmetrized object. The options \verb|-E,-I,-L| ask for the input of a polynomial. See Section~\ref{poly_input}.

\subsubsection{Markov and Gröbner bases}

They are discussed in Section \ref{AffMon}.
\begin{itemize}
	\itemtt[MarkovBasis] computes a system of generators for a toric ideal defining a monoid or a lattice ideal. 
	\itemtt[GroebnerBasis] computes a system of generators for such ideals.
	\itemtt[Representations] compites the represenztation of the reducible elements in a generating system of an affine monoid by the Hilbert basis.
	\itemtt[Lex] sets the lexicographic monomial order for Gröbner bases,
	\itemtt[RevLex] sets the degree reverse lexicographic order,
	\itemtt[DegLex] sets the degree lexicographic order.
\end{itemize}

\subsubsection{Local structure}

\begin{itemize}
	\itemtt[SingularLocus] comoputes the singular locus of an affine monoid (algebra),
	\itemtt[CodimSingularLocus] computes its codimension. 
\end{itemize}

\subsubsection{Boolean valued computation goals}\label{bool}

They tell Normaliz to find out the answers to the questions they ask. Two of them are more important than the others since they may influence the course of the computations:

\begin{itemize}
	\itemtt[IsIntegrallyClosed]: is the original monoid integrally closed? Normaliz stops the Hilbert basis computation as soon as it can decide whether the original monoid contains the Hilbert basis (see Section~\ref{IsIC}). Normaliz tries to find the answer as quickly as possible. This may include the computation of a witness, but not necessarily. If you need a witness, use \verb|WitnessNotIntegrallyClosed, -w|.
	
	\itemtt[IdsSerreR1] checks the Serre property $(R_1)$ for ffine monoids (automatically satisfied by normal monoids).
	
	\itemtt[IsPointed]: is the efficient cone $\CC$ pointed? This computation goal is sometimes useful to give Normaliz a hint that a nonpointed cone is to be expected. See Section~\ref{IsPointed}.
\end{itemize}

For the following we only need the support hyperplanes and the lattice:

\begin{itemize}
	\itemtt[IsGorenstein, -G]: is the monoid of lattice points Gorenstein? In addition to answering this question, Normaliz also computes the generator of the interior of the monoid (the canonical module) if the monoid is Gorenstein. (Only in homogeneous computations.)
\end{itemize}

The remaining ones:

\begin{itemize}
	
	\itemtt[IsDeg1ExtremeRays]: do the extreme rays have degree~$1$? (Only in homogeneous computations.)
	
	\itemtt[IsDeg1HilbertBasis]: do the Hilbert basis elements have degree~$1$? (Only in homogeneous computations.)
	
	\itemtt[IsReesPrimary]: for the input type \verb|rees_algebra|, is the monomial ideal primary to the irrelevant maximal ideal?
	
	\itemtt[IsLatticeIdealToric] asks whether the \verb|lattice ideal| in the input is actually toric 
	
\end{itemize}

The last three computation goals are not really useful for Normaliz since they will be answered automatically. Note that they may trigger extensive computations.

\subsubsection{Fusion rings}

See Appendix \ref{fusion_rings}.

\subsection{Integer type}\label{Integer}

There is no need to worry about the integer type chosen by Normaliz. All preparatory computations use infinite precision. The main computation is then tried with $64$ bit integers. If it fails, it will be restarted with infinite precision.

Infinite precision does not mean that overflows are completely impossible. In fact, Normaliz requires numbers of type ``degree'' fit the type \verb|long| (typically~$64$~bit on~$64$~bit systems). If an overflow occurs in the computation of such a number, it cannot be remedied.

The amount of computations done with infinite precision is usually very small, but the transformation of the computation results from~$64$~bit integers to infinite precision may take some time. If you need the highest possible speed, you can suppress infinite precision completely by
\begin{itemize}
	\itemtt[LongLong]
\end{itemize}
With this option, Normaliz cannot restart a failed computation.

On the other hand, the $64$ bit attempt can be bypassed by
\begin{itemize}
	\itemtt[BigInt, -B]
\end{itemize}

Note that Normaliz tries to avoid overflows by intermediate results (even if \verb|LongLong| is set). If such overflow should happen, the computation is repeated locally with infinite precision. (The number of such GMP transitions is shown in the terminal output.) If a final result is too large, Normaliz must restart the computation globally.

\verb|LongLong| is not a cone property.

\emph{Caveat.}\enspace The overflow check of Normaliz is not an absolute guarantee. The probability that it fails is microscopically small, but failure is not totally excluded. Very critical computations for which one has no other confirmation should be redone in \verb|BigInt|.


\subsection{The choice of algorithmic variants}

For its main computation goals Normaliz has algorithmic variants. It tries to choose the variant that seems best for the given input data. This automatic choice may however be a bad one. Therefore the user can completely control which algorithmic variant is used.

\subsubsection{Primal vs.\ dual}

For the computation of Hilbert bases Normaliz has two algorithms, the primal algorithm that is based on triangulations, and the dual algorithm that is of type ``pair completion''. We have seen both in Section~\ref{Examples}. Roughly speaking, the primal algorithm is the first choice for generator input, and the dual algorithm is usually better for constraints input. The choice also applies to the computation of degree $1$ elements. However, for them the default choice is project-and-lift (well, almost always). See Section~\ref{project}. The conditions under which the dual algorithm is chosen are specified in Section~\ref{div_labor}.

The choice of the algorithm can be fixed or blocked:
\begin{itemize}
	\itemtt[DualMode, -d] activates the dual algorithm for the computation of the Hilbert basis and degree $1$ elements. Includes \verb|HilbertBasis|, unless \verb|Deg1Elements| is set. It overrules \verb|IsIntegrallyClosed|.
	
	\itemtt[PrimalMode, -P] blocks the use of the dual algorithm.
\end{itemize}

The automatic choice can of course fail. See Section~\ref{div_labor} for an example for which it is bad.

\subsubsection{Lattice points in polytopes}\label{approximate}

For this task Normaliz has several methods. They are discussed in Section~\ref{LattPoints}. The default choice is the project-and-lift algorithm. It can be chosen explicitly:
\begin{itemize}
	\itemtt[Projection, -j]
	
	\itemtt[NoProjection] blocks it.
\end{itemize}

Alternative choices are
\begin{itemize}
	\itemtt[ProjectionFloat, -J], project-and-lift with floating point arithmetic,
	\itemtt[PrimalMode, -P], triangulation based method,
	\itemtt [Approximate, -r], approximation of rational polytopes followed by triangulation and
	\itemtt[DualMode, -d], dual algorithm.
\end{itemize}
Note: none of these algorithmic variants implies the computation of the lattice points. They must be asked for by a computation goal.

The following options modify \verb|Projection| and \verb|ProjectionFloat|:
\begin{itemize}
	\itemtt[NoLLL] blocks the use of LLL reduced coordinates,
	\itemtt[NoRelax] blocks relaxation.
\end{itemize}
Both LLL and relaxation are switched on by default. See Section~\ref{LLL}.

For positive systems (see Section \ref{positive_systems}) Normaliz chooses  ``coarse projection'', and it may use a patching variant of project-and-lift. These choices can be blocked by
\begin{itemize}
	\itemtt[NoCoarseProjection]
	\itemtt[NoPatching]  
\end{itemize}
Moreover, there are further options by which the order, in which the ``patches'' are processed, can be influenced. See Section \ref{patch_order}.

\subsubsection{Bottom decomposition and order}

Bottom decomposition is a way to produce an optimal triangulation for a given set of generators. It is discussed in Section~\ref{bottom_dec}. The criterion for its automatic choice is explained there. It can be forced or blocked:
\begin{itemize}
	\itemtt[BottomDecomposition, -b] tells Normaliz to use bottom decomposition in the primal algorithm.
	
	\itemtt[NoBottomDec, -o] forbids Normaliz to use bottom decomposition in the primal algorithm, even if it would otherwise be chosen because of large roughness (see Section~\ref{bottom_dec}).
\end{itemize}

An option to be mentioned in this context is
\begin{itemize}
	\itemtt[KeepOrder, -k]  forces Normaliz to insert the generators (for generator input) or the inequalities (for constraint input) in the input order. This option is useful if the input has been produced in a systematic order that would be destroyed by the degree-lexicogrpahic order applied by Normaliz. Also blocks \verb|BottomDecomposition|.
\end{itemize}


\subsubsection{Multiplicity, volume and integrals}
For the computation of multiplicities Normaliz offers has three main algorithms:
\begin{arab}
	\item the computation and evaluation of a full triangulation,
	\item descent in the face lattice,
	\item signed decomposition.
\end{arab}
These are described in more detail in Section \ref{VariousVolumes}. Moreover, one can use  symmetrization (see below), and (2) has a variant using isomorphism types.

Normaliz tries them by default in the order signed decoposition, descent, symmetritation and uses the first for which the default conditions are satisfied (as long as there is no need to compute a full triangulation for other reasons). The last resort is (1).

The options asking explicitly for an algorithm  or excluding it are
\begin{itemize}
	\itemtt[Descent, -F]
	\itemtt[NoDescent]
	\itemtt[SignedDec]
	\itemtt[NoSignedDec]
\end{itemize}

The variant using isomorphism types can be activated by
\begin{itemize}
	\itemtt[Descent ExploitIsosMult]
\end{itemize}
You van ask for
\begin{itemize}
	\itemtt[StrictTypeChecking]
\end{itemize}
if you don't btrust SHA256 hash values. See Section \ref{ExploitIsosoMult}.

Another option to be mentioned in this context is
\begin{itemize}
	\itemtt[FixedPrecision]
\end{itemize}
It can be applied if the multiplicity is computed by signed decomposition. See Section \ref{FixedPrecision}

For integrals one can chose either the standard triangulation or signed decomposition. In the latter case \verb|FixedPrecision| is also available.

If one wants to compute multiplicities (or volumes)  with signed decomposition, one can use distributed computation on a HPC. Distributed computation is described in Appendix \ref{distr_comp}.

\subsubsection{Symmetrization}

In rare cases Normaliz can use symmetrization in the computation of multiplicities or Hilbert series. If applicable, this is a very strong tool. We have mentioned it in Section~\ref{Condorcet} and will discuss it in Section~\ref{symmetrize}. It will be chosen automatically, but can also be forced or blocked:
\begin{itemize}
	\itemtt[Symmetrize, -Y] lets Normaliz compute the multiplicity and/or the Hilbert series via symmetrization (or just compute the symmetrized cone).
	
	\itemtt[NoSymmetrization] blocks symmetrization.
\end{itemize}

The integration involved in symmetrization can be done by signed decomposition.

\subsubsection{Subdivision of simplicial cones}

Subdivision requires enlarging the set of generators and can lead to a nested triangulation (see Sections~\ref{subdiv} and~\ref{nested}). The subdivision can be blocked by
\begin{itemize}
	\itemtt[NoSubdivision]
\end{itemize}

\subsubsection{Options for the grading}

By setting
\begin{itemize}
	\itemtt[NoGradingDenom]
\end{itemize}
you can force Normaliz not to change the original grading if it would otherwise divide it by the grading denominator. It is implied by several computation goals for polytopes. See Section~\ref{Polytopes}.

\verb|NoGradingDenom| \emph{is set automatically inn inhomogeneous computations.}

By
\begin{itemize}
	\itemtt[GradingIsPositive]
\end{itemize}
the user guarantees that the grading is positive. This option can be useful in rare cases if Normaliz would otherwise compute extreme rays only to check the positivity of the grading.

\subsection{Control of computations and communication with interfaces}

In addition to the computation goals in Section~\ref{goals},
the following elements of \verb|ConeProperties| control the work flow in \verb|libnormaliz| and can be used by programs calling Normaliz to ensure the availability of the data that are controlled by them.

\begin{itemize}
	
	\itemtt[OriginalMonoidGenerators] controls the generators of the original monoid.
	
	\itemtt[ModuleGenerators] controls the module generators in inhomogeneous computation.
	
	\itemtt[ExtremeRays] controls the extreme rays.
	
	\itemtt[VerticesOfPolyhedron] controls the vertices of the polyhedron in the inhomogeneous case.
	
	\itemtt[MaximalSubspace] controls the maximal linear subspace of the (homogenized) cone.
	
	\itemtt[EmbeddingDim] controls the embedding dimension.
	\itemtt[Rank] controls the rank.
	
	\itemtt[RecessionRank] controls the rank of the recession monoid in inhomogeneous computations.
	
	\itemtt[AffineDim] controls the affine dimension of the polyhedron in inhomogeneous computations.
	
	\itemtt[ModuleRank] in inhomogeneous computations it controls the rank of the module of lattice points in the polyhedron as a module over the recession monoid.
	
	\itemtt[ExcludedFaces] controls the excluded faces.
	
	\itemtt[InclusionExclusionData] controls data derived from the excluded faces.
	
	\itemtt[Grading] controls the grading.
	\itemtt[GradingDenom] controls its denominator.
	
	\itemtt[Dehomogenization] controls the dehomogenization.
	
	\itemtt[ReesPrimaryMultiplicity] controls the multiplicity of a monomial ideal, provided it is primary to the maximal ideal generated by the indeterminates. Used only with the input type \verb|rees_algebra|.
	
	\itemtt[EuclideanVolume]controls the Euclidean volume.
	
	\itemtt[GeneratorOfInterior] controls the generator of the interior if the monoid is Gorenstein.
	
	\itemtt[CoveringFace] asks for an excluded face making the semiopen polyhedron empty.
	
	\itemtt[Equations] controls the equations.
	\itemtt[Congruences] controls the congruences.
	\itemtt[ExternalIndex] controls the external index.
	\itemtt[InternalIndex] controls the internal index.
	\itemtt[UnitGroupIndex] controls the unit group index.	
	
	\itemtt[IsInhomogeneous] controls the inhomogeneous case.
	
	\itemtt[HilbertQuasiPolynomial] controls the Hilbert quasipolynomial.
	\itemtt[EhrhartQuasiPolynomial] controls the Ehrhart quasipolynomial.
	
	\itemtt[WeightedEhrhartQuasiPolynomial] controls the weighted Ehrhart quasipolynomial.
	
	\itemtt[IsTriangulationNested] controls the indicator of this property.
	\itemtt[IsTriangulationPartial] similar.
	
\end{itemize}

\subsection{Rational and integer solutions in the inhomogeneous case}\label{InhomDual}

The integer solutions of a homogeneous diophantine system generate the rational solutions as well: every rational solution has a multiple that is an integer solution. Therefore the rational solutions do not need an extra computation. If you prefer geometric language: a rational cone is generated by its lattice points.

This is no longer true in the inhomogeneous case where the computation of the rational solutions is an extra task for Normaliz. This extra step is inevitable for the primal algorithm, but not for the dual algorithm. In general, the computation of the rational solutions is much faster than the computation of the integral solutions, but this by no means always the case.

Therefore we have decoupled the two computations if the dual algorithm is applied to inhomogeneous systems or to the computation of degree $1$ points in the homogeneous case. The combinations
\begin{itemize}
	\itemtt[DualMode HilbertBasis, -dN]
	
	\itemtt[DualMode Deg1Elements, -d1]
	
	\itemtt[DualMode ModuleGenerators]
	
	\itemtt[DualMode LatticePoints]
	
\end{itemize}
do not imply the computation goal \verb|SupportHyperplanes| (and not even \verb|Sublattice|) which would trigger the computation of the rational solutions (geometrically: the vertices of the polyhedron). If you want to compute them, you must add one of
\begin{itemize}
	\itemtt[SupportHyperplanes, -s]
	
	\itemtt[ExtremeRays]
	
	\itemtt[VerticesOfPolyhedron]
\end{itemize}
The last choice is only possible in the inhomogeneous case. Another possibility in the inhomogeneous case is is to use \verb|DualMode| without a restriction.

If \verb|Projection| or \verb|ProjectionFloat| is used for parallelotopes defined by inequalities, then Normaliz does not compute the vertices, unless asked for by one of the three computation goals just mentioned or the extreme rays are needed for some other computation. The same holds if the volume of a parallelotope is computed.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  RUNNING  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running Normaliz}\label{options}

The standard form for calling Normaliz is
\begin{quote}
	\verb|normaliz [options]| <project>
\end{quote}
where \verb|<project>| is the name of the project, and the corresponding input file is \verb|<project>.in|. Note that \verb|normaliz| may require to be prefixed by a path name, and the same applies to \verb|<project>|. A typical example on a Linux or Mac system:
\begin{quote}
	\verb|./normaliz --verbose -x=5 example/big|
\end{quote}
that for MS~Windows must be converted to
\begin{quote}
	\verb|.\normaliz --verbose -x=5 example\big|
\end{quote}

Normaliz uses the standard conventions for calls from the command line:
\begin{arab}
	\item the order of the arguments on the command line is arbitrary.
	\item Single letter options are prefixed by the character \verb|-| and can be grouped into one string.
	\item Verbatim options are prefixed by the characters \verb|--|.
\end{arab}

The options for computation goals and algorithmic variants have been described in Section~\ref{Goals}. In this section the remaining options for the control of execution and output are discussed, together with some basic rules for the use of the options.

\subsection{Basic rules}
The options for computation goals and algorithms variants have been explained in Section~\ref{Goals}. The options that control the execution and the amount of output will be explained in the following. Basic rules for the use of options:

\begin{enumerate}
	\item If no \ttt{<project>} is given, the
	program will terminate.
	
	\item The option \ttt{-x} differs from the other ones: \ttt{<T>} in \verb|-x=<T>|
	represents a positive number assigned to \ttt{-x}; see
	Section~\ref{exec}.
	
	\item Similarly the option \ttt{---OutputDir=<outdir>} sets the output directory; see~\ref{outcontrol}.
	
	\item Normaliz will look for \ttt{<project>.in} as input
	file.
	
	If you inadvertently typed \ttt{rafa2416.in} as the project
	name, then Normaliz will first look for \ttt{rafa2416.in.in}
	as the input file. If this file doesn't exist,
	\ttt{rafa2416.in} will be loaded.
	
	\item The options can be given in arbitrary order. All options, including those in the input file, are accumulated, and syntactically there is no mutual exclusion. However, some options may block others during the computation. For example, \verb|KeepOrder| blocks \verb|BottomDecomposition|.
	
	\item If Normaliz cannot perform a computation explicitly asked for by the
	user, it will terminate. Typically this happens if no grading is given although
	it is necessary.
	
	\item In the options include \verb|DefaultMode|, Normaliz does not complain about missing data
	(anymore). It will simply omit those computations that are impossible.
	
	\item If a certain type of computation is not asked for explicitly, but can
	painlessly be produced as a side effect, Normaliz will compute it. For
	example, as soon as a grading is present and the Hilbert basis is computed, the
	degree $1$ elements of the Hilbert basis are selected from it.
	
	In addition to computing a single file per run, Normaliz can also process a list of input files. See Section \ref{input_list}.
	
\end{enumerate}

\subsection{Info about Normaliz}

\begin{itemize}
	\itemtt [-{}-help, -?] displays a help screen listing the Normaliz options.
	
	\itemtt [-{}-version] displays information about the Normaliz executable.
\end{itemize}


\subsection{Control of execution}\label{exec}

The options that control the execution are:

\begin{itemize}
	\itemtt[-{}-verbose, -c] activates the verbose (``console'') behavior of
	Normaliz in which Normaliz writes additional
	information about its current activities to the
	standard output.
	
	\itemtt[-{}-talk] gives more output than \verb*|verbose| (at present only implemented in the patching variant of project-and-lift)
	
	\itemtt[-x=<T>] Here \ttt{<T>} stands for a positive
	integer limiting the number of threads that Normaliz
	is allowed access on your system. The default value is
	$8$. (Your operating system may set a lower limit).
	
	\ttt{-x=0} switches off the limit set by Normaliz.
	
	If you want to run
	Normaliz in a strictly serial mode, choose
	\ttt{-x=1}.

	\itemtt[parallel\_threads <T>] can be used in the input file instead.
\end{itemize}

The number of threads can also be controlled by the environment
variable \verb+OMP_NUM_THREADS+. See Section~\ref{PerfPar} for
further discussion.

If there ar5e many polynomials in the input it can be difficult to find an error in them. As a help ion such cases one can say
\begin{itemize}
	\itemtt[list\_polynomials]
\end{itemize}
The last polynomial listed has caused the error.

\subsection{Interruption}\label{interrupt}

During a computation \verb|normaliz| can be interrupted by pressing Ctrl-C on the keyboard. If this happens, Normaliz will stop the current computation and write the already computed data to the output file(s). By
\begin{itemize}
	\itemtt[NoOutputOnInterrupt]
\end{itemize}
the output of data can be blocked. Can be set in the input file or on the command line as a long option.

If Ctrl-C is pressed during the output phase, Normaliz is stopped immediately.

\subsection{Stopping a computation}

If Normaliz is running in the background and cannot be interrupted by CTrl-C, then one can stop it by inserting a file
\begin{itemize}
	\itemtt[normaliz.stop]
\end{itemize}
into the working directory. This will stop (possibly with some delay) the instances of normaliz running in that directory. In order to stop a specific instance, use
\begin{itemize}
	\itemtta[<project>.stop]{project>.stop}
\end{itemize}

\subsection{Time bound}\label{time_bound}

In order to set a time bound for the execution of Normaliz one creates a file
\begin{itemize}
	\itemtt[normaliz.time]
\end{itemize}
in the working directory. It contains a single floating number that bounds the wall clock time of Normaliz. At present it is only implemented in the project-and-lift algorithm for lattice points. 

\subsection{Control of output files}\label{outcontrol}

In the default setting Normaliz writes only the output file
\ttt{<project>.out} (and the files produced by \ttt{Triangulation}, \ttt{StanleyDec} and \ttt{FaceLattice}). The
amount of output files can be
increased as follows:
\begin{itemize}
	\itemtt[{-}{-}files, -f] Normaliz writes the additional output files
	with suffixes \ttt{gen}, \ttt{cst}, and \ttt{inv},
	provided the data of these files have been computed.
	\itemtt[{-}{-}all-files, -a] includes \ttt{Files}, Normaliz writes all
	available output files (except \verb|typ| and those that are automatically written by computation goals).
	\itemtt [{-}{-}<suffix>] chooses the output file with suffix \verb|<suffix>|.
\end{itemize}

For the list of potential output files, their suffixes and their interpretation
see Section~\ref{optionaloutput}. There are several options \verb|--<suffix>|.

If the computation goal \verb|IntegerHull| is set, Normaliz computes a second cone and lattice. The output is contained in \verb|<project>.IntHull.out|. The options for the output of \verb|<project>| are applied to \verb|<project>.IntHull| as well. There is no way to control the output of the two computations individually.

Similarly, if symmetrization has been used, Normaliz writes the file \verb|<project>.symm.out|. It contains the data of the symmetrized cone.

Sometimes one wants the output to be written to another directory. The output directory can be set by
\begin{itemize}
	\itemtta[{-}{-OutputDir=<outdir>}]{OutputDir=<outdir}. The path \ttt{<outdir>} is an absolute path or a path relative to the current directory (which is not necessarily the directory of \verb|<project>.in|.)
\end{itemize}
Note that all output files will be written to the chosen directory. It must be created before Normaliz is started.

Extreme rays and vertices may have very long integer coordinates. One can suppress their output by
\begin{itemize}
	\itemtt[NoExtRaysOutput]
\end{itemize}
For similar reasons one may want to suppress the output of support hyperplanes, namely by
\begin{itemize}
	\itemtt[NoSuppHypsOutput]
\end{itemize}
Similarly,
\begin{itemize}
	\itemtt[NoHilbertBasisOutput]
\end{itemize}
supprsesses thze output of Hilbert bases and latticec points.
An even more drastic option is
\begin{itemize}
	\itemtt[NoMatricesOutput]
\end{itemize}
It suppresses all output after the ``preamble''. It is useful in testing large examples where the numbers of extreme rays, lattice points etc.\ are usually a good criterion for correctness.

\verb|NoExtRaysOutput|, \verb|NoSuppHypsOutput|and \verb|NoMatricesOutput| are not cone properties.

\begin{itemize}
	\itemtt[BinomialsPacked] chooses a packed format for files containing binomials. See Section \ref{BinomialsPacked}.
\end{itemize}


\subsection{Ignoring the options in the input file}

Since Normaliz accumulates options, one cannot get rid of settings in the input file by command line options unless one uses
\begin{itemize}
	\itemtt[{-}{-}ignore, -i] This option disables all options in the input file.
\end{itemize}
